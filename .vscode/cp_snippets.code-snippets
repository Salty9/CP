{
  "random": {
    "prefix": "random",
    "body": [
      "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());"
    ],
    "description": "random"
  },
  "gp_hash_table": {
    "prefix": "gp_hash_table",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "struct custom_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "};",
      "",
      "template<typename S, typename T>",
      "using hash_table = gp_hash_table<S, T, custom_hash>;",
      "// Usage: hashtable<int, int> for map<int, int> basically",
      "// replacement for unordered_set<K>, use gp_hash_table<K, null_type>",
      "// Note: the operator needs to be able to hash the typename S",
      "",
      "",
      "// untested but could be used for pairs",
      "// the hashes need to be non symmetric ((a, b) and (b, a) should give diff hash)",
      "// eg: splitmix64(x.first ^ splitmix64(x.second) ^ FIXED_RANDOM) works",
      "// but splitmix64(x.first ^ x.second ^ FIXED_RANDOM) doesnt since (1, 2) and (2, 1) give same hash",
      "",
      "// maybe this for pairs",
      "",
      "// size_t operator()(pair<uint64_t, uint64_t> x) const {",
      "// static const uint64_t FIXED_RANDOM =",
      "//     chrono::steady_clock::now().time_since_epoch().count();",
      "//     return splitmix64(x.first ^ splitmix64(x.second) ^ FIXED_RANDOM);",
      "// }",
      "",
      "//maybe this for strings",
      "",
      "// size_t operator()(string x) const {",
      "//   static const uint64_t FIXED_RANDOM =",
      "//       chrono::steady_clock::now().time_since_epoch().count();",
      "//   uint64_t hash = 0;",
      "//   for (char c : x){",
      "//       hash = splitmix64(hash ^ (c + 1) ^ FIXED_RANDOM);",
      "//   }",
      "//   return hash;",
      "// }"
    ],
    "description": "gp_hash_table"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "template<int MOD, int RT> struct Mint {",
      "    static const int mod = MOD;",
      "    static constexpr Mint rt() { return RT; } // primitive root for FFT",
      "    int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
      "    Mint():v(0) {}",
      "    Mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD); if (v < 0) v += MOD; }",
      "",
      "    bool operator==(const Mint& o) const { return v == o.v; }",
      "    friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }",
      "    friend bool operator<(const Mint& a, const Mint& b) { return a.v < b.v; }",
      "",
      "    Mint& operator+=(const Mint& o) { if ((v += o.v) >= MOD) v -= MOD; return *this; }",
      "    Mint& operator-=(const Mint& o) { if ((v -= o.v) < 0) v += MOD; return *this; }",
      "    Mint& operator*=(const Mint& o) { v = int((ll)v*o.v%MOD); return *this; }",
      "    Mint& operator/=(const Mint& o) { return (*this) *= inv(o); }",
      "    friend Mint pow(Mint a, ll p) {",
      "        Mint ans = 1; assert(p >= 0);",
      "        for (; p; p /= 2, a *= a) if (p&1) ans *= a; return ans; }",
      "    friend Mint inv(const Mint& a) { assert(a.v != 0); return pow(a,MOD-2); }",
      "",
      "    Mint operator-() const { return Mint(-v); }",
      "    Mint& operator++() { return *this += 1; }",
      "    Mint& operator--() { return *this -= 1; }",
      "    friend Mint operator+(Mint a, const Mint& b) { return a += b; }",
      "    friend Mint operator-(Mint a, const Mint& b) { return a -= b; }",
      "    friend Mint operator*(Mint a, const Mint& b) { return a *= b; }",
      "    friend Mint operator/(Mint a, const Mint& b) { return a /= b; }",
      "    friend ostream& operator<<(ostream &out, const Mint &m) {return out << m.v;}",
      "    friend istream& operator>>(istream &in, Mint &m) {long long x; in >> x; m = Mint(x); return in;}",
      "};",
      "const int MOD = (int)1e9 + 7; // change accordingly",
      "using mint = Mint<MOD,5>;"
    ],
    "description": "mint"
  },
  "base": {
    "prefix": "base",
    "body": [
      "#ifdef LOCAL",
      "#include \"algo/dbg.hpp\"",
      "#else",
      "#include \"bits/stdc++.h\"",
      "#define dbg(...)",
      "#endif",
      "using namespace std;",
      "",
      "#define endl '\\n'",
      "#define pb push_back",
      "#define all(v) v.begin(), v.end()",
      "#define rep(i,a,b) for (int i = (a); i < (b); ++i)",
      "#define rrep(i,a,b) for (int i = (a); i >= (b); --i)",
      "",
      "typedef long long ll;",
      "typedef pair<int, int> pii;",
      "typedef vector<int> vi;",
      "template<class T> bool ckmin(T& a, T b){ return b < a ? a = b, 1 : 0; }",
      "template<class T> bool ckmax(T& a, T b){ return b > a ? a = b, 1 : 0; }",
      "template<class T> istream& operator>>(istream&i,vector<T>&v){for(T&x:v)i>>x;return i;}",
      "",
      "void solve(int tc = 0) {",
      "    $0",
      "}",
      "",
      "signed main() {",
      "ios_base::sync_with_stdio(false);",
      "cin.tie(NULL); cout.tie(NULL);",
      "",
      "int tc = 1;",
      "$1//cin >> tc;",
      "for(int t = 0; t < tc; t++) solve(t);",
      "}"
    ],
    "description": "base"
  },
  "number_theory": {
    "prefix": "number_theory",
    "body": [
      "vector<int> primes, spf;",
      "",
      "void Spf(int lim){ // lim=1e8 -> 0.8 sec.",
      "\tspf.resize(lim); // smallest prime that divides",
      "    rep(i,2,lim) {",
      "        if (spf[i] == 0) spf[i] = i, primes.pb(i);",
      "        for (int p: primes) {",
      "            if (p > spf[i] || i*p >= lim) break;",
      "            spf[i*p] = p;",
      "        }",
      "    }",
      "};",
      "",
      "vector<pair<ll,ll>> factorize(ll x) { // {exp, cnt} pair in O(sqrt x) or O(log x) if spf_generated",
      "\tvector<pair<ll,ll>> res;",
      "    if(spf.size() > 0){",
      "        assert(x < spf.size());",
      "        while(x > 1){",
      "            ll p = spf[x];",
      "            ll cnt = 0;",
      "            while(x % p == 0) x /= p, cnt++;",
      "            res.pb({p, cnt});",
      "        }",
      "        return res;",
      "    }",
      "\tfor(ll i = 2; i*i <= x; ++i) if(x % i == 0) {",
      "\t\tll cnt = 0;",
      "\t\twhile (x % i == 0) x /= i, cnt++;",
      "\t\tres.pb({i,cnt});",
      "\t}",
      "\tif(x > 1) res.pb({x,1});",
      "\treturn res;",
      "}",
      "",
      "vector<ll> divisors(ll x){",
      "    vector<ll> divs;",
      "    for(ll i = 1; i * i <= x; i++) {",
      "        if(x % i == 0) {",
      "            divs.push_back(i);",
      "            if(i*i != x) divs.push_back(x / i);",
      "        }",
      "    }",
      "    return divs;",
      "}"
    ],
    "description": "number_theory"
  },
  "timeit": {
    "prefix": "timeit",
    "body": [
      "#ifdef LOCAL",
      "    auto begin = std::chrono::high_resolution_clock::now();",
      "    // freopen(\"input\",\"r\",stdin);",
      "    //freopen(\"a.out\",\"w\",stdout); // console output is better (in most cases)",
      "#endif",
      "",
      "#ifdef LOCAL",
      "    auto end = std::chrono::high_resolution_clock::now();",
      "    cerr << setprecision(4) << fixed;",
      "    cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;",
      "#endif"
    ],
    "description": "timeit"
  },
  "lazy_segtree": {
    "prefix": "lazy_segtree",
    "body": [
      "template<class Lazy, class Info>",
      "struct LazySeg {",
      "    vector<Lazy> lazy;",
      "    vector<Info> seg;",
      "    int SZ = 1;",
      "    LazySeg(const int _sz, Info Initial = Info()) {",
      "        while (SZ < _sz) SZ *= 2;",
      "        seg.assign(2*SZ, Initial); lazy.resize(2*SZ);",
      "        for(int i = SZ-1; i >= 1; i--) pull(i);",
      "    }",
      "    LazySeg(const vector<Info>& _seg) {",
      "        while (SZ < _seg.size()) SZ *= 2;",
      "        seg.resize(2*SZ); lazy.resize(2*SZ);",
      "        for(int i = 0; i < SZ and i < _seg.size(); i++) seg[SZ+i] = _seg[i];",
      "        for(int i = SZ-1; i >= 1; i--) pull(i);",
      "    }",
      "    void push(int ind) {// modify values for current node (lazy upds floatin until pushed)",
      "        seg[ind] *= lazy[ind];",
      "        if (ind < SZ) rep(i,0, 2) lazy[2*ind+i] *= lazy[ind];",
      "        lazy[ind] = Lazy();",
      "    }",
      "    void pull(int ind) { seg[ind] = seg[2*ind]+seg[2*ind+1]; }",
      "",
      "    // CATION: CHOOSE PROPERLY WHETHER UPDATES SHOULD BE SET OR INCREMENTED !!!!!",
      "    void upd(int lo, int hi, Lazy inc, int ind, int L, int R) {",
      "        push(ind);",
      "        if (hi < L || R < lo) return;",
      "        if (lo <= L && R <= hi) { lazy[ind] = inc; push(ind); return;}",
      "        int M = (L+R)/2;",
      "        upd(lo,hi,inc,2*ind,L,M);",
      "        upd(lo,hi,inc,2*ind+1,M+1,R);",
      "        pull(ind);",
      "    }",
      "    void upd(int lo, int hi, Lazy inc) { return upd(lo, hi, inc, 1, 0, SZ-1); }",
      "",
      "    Info query(int lo, int hi, int ind, int L, int R) {",
      "        push(ind);",
      "        if (lo > R || L > hi) return Info();",
      "        if (lo <= L && R <= hi) return seg[ind];",
      "        int M = (L+R)/2;",
      "        return query(lo,hi,2*ind,L,M) + query(lo,hi,2*ind+1,M+1,R);",
      "    }",
      "    Info query(int lo, int hi){ return query(lo, hi, 1, 0, SZ-1);}",
      "",
      "    // 0 based range and index for upd and query, root at 1, 2*ind, 2*ind + 1 children",
      "    template<class F>",
      "    int walk(int p, int l, int r, int x, int y, F &&pred) {",
      "        if (l > y || r < x) return -1;",
      "        push(p);",
      "        if (l >= x && r <= y && !pred(seg[p])) return -1;",
      "        if (r == l) return l;",
      "        int m = (l + r)/ 2;",
      "        int res = walk(2*p, l, m, x, y, pred);//find_last: flip res order(right range 1st)",
      "        if (res == -1) res = walk(2*p + 1, m+1, r, x, y, pred);",
      "        return res;",
      "    }",
      "    template<class F> int walk(int l, int r, F &&pred) { return walk(1, 0, SZ-1, l, r, pred); }",
      "    // given 0 based inclusive range [x, y], first time pred(use lambda) is true",
      "};",
      "struct Lazy {",
      "    int inc;",
      "    Lazy(int x = 0): inc(x) {}",
      "    Lazy& operator*=(const Lazy& a) {",
      "        inc += a.inc;",
      "        return *this;",
      "    }",
      "};",
      "struct Info { // info you need to store for each interval",
      "    int mx;",
      "    Info(int x = -1e9): m {}",
      "    friend Info operator+(const Info& a, const Info& b) {",
      "        return Info(max(a.mx, b.mx));",
      "    }",
      "    Info& operator*=(const Lazy& a) {",
      "        // sum += sz*a.add;",
      "        ckmax(mx, a.mx);",
      "        return *this;",
      "    }",
      "};",
      "// range combiner function (Info +) has to be ASSOCIATIVE (to combine Info freely in the recursive call order)",
      "// update combiner function (Lazy +=) has to be ASSOCIATIVE (to combine updates into one big update)",
      "// update has to be DISTRIBUTE over range combiner function.",
      "// upd(Info x) + upd(Info y) = upd(Info x + Info y) eg. min({l,r}+v, {L,R}+v) = min({l,r}, {L,R}) + v",
      "// allows storing the update on both x and y, on their parent (dont have to push everything to leaf). push/distribute when needed",
      ""
    ],
    "description": "lazy_segtree"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template<class T> struct Segtree {",
      "   // initialize ID if need nonzero & define cmb so that cmb(ID,b) = b",
      "    const T ID{};",
      "    T cmb(T a, T b) {",
      "        return a + b;",
      "    }",
      "    int n = 1; vector<T> seg;",
      "    Segtree(int _n){while(n < _n) n *= 2; seg.assign(2*n,ID);}",
      "    void pull(int p) { seg[p] = cmb(seg[2*p],seg[2*p+1]); }",
      "",
      "    // CATION: CHOOSE PROPERLY WHETHER UPDATES SHOULD BE SET OR INCREMENTED !!!!!",
      "    void upd(int p, T val) { seg[p += n] = val; for (p /= 2; p; p /= 2) pull(p); }",
      "    T query(int l, int r) {",
      "        T ra = ID, rb = ID;",
      "        for (l += n, r += n+1; l < r; l /= 2, r /= 2) {",
      "            if (l&1) ra = cmb(ra,seg[l++]);",
      "            if (r&1) rb = cmb(seg[--r],rb);",
      "        }",
      "        return cmb(ra,rb);",
      "    }",
      "    // 0 based range and index for upd and query, root at 1, 2*ind, 2*ind+1 children",
      "    template<class F>",
      "    int walk(int p, int l, int r, int x, int y, F &&pred) {",
      "        if (l > y || r < x) return -1;",
      "        if (l >= x && r <= y && !pred(seg[p])) return -1;",
      "        if (r == l) return l;",
      "        int m = (l + r) / 2;",
      "        int res = walk(2 * p, l, m, x, y, pred);//find_last: flip res order(right range 1st)",
      "        if (res == -1) res = walk(2 * p + 1, m+1, r, x, y, pred);",
      "        return res;",
      "    }",
      "    template<class F> int walk(int l, int r, F &&pred) { return walk(1, 0, n-1, l, r, pred); }",
      "    // given 0 based inclusive range [x, y], first time pred(use lambda) is true",
      "};"
    ],
    "description": "segtree"
  },
  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <bits/extc++.h>",
      "using namespace __gnu_pbds;",
      "",
      "template<class T>",
      "using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// Usage: Tree<int> t; order_of_key, find_by_order",
      "// submit with g++177"
    ],
    "description": "pbds"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct Dsu {",
      "\tvector<int> p;",
      "\tDsu(int n) : p(n, -1) {}",
      "\tbool sameSet(int a, int b) { return parent(a) == parent(b); }",
      "\tint size(int x) { return -p[parent(x)]; }",
      "\tint parent(int x) { return p[x] < 0 ? x : p[x] = parent(p[x]); }",
      "\tbool unite(int a, int b) {",
      "\t\ta = parent(a), b = parent(b);",
      "\t\tif (a == b) return false;",
      "\t\tif (p[a] > p[b]) swap(a, b);",
      "\t\tp[a] += p[b]; p[b] = a;",
      "\t\treturn true;",
      "\t}",
      "};"
    ],
    "description": "dsu"
  },
  "fenwick": {
    "prefix": "fenwick",
    "body": [
      "struct Fenwick {",
      "\tvector<ll> s;",
      "\tFenwick(int n) : s(n) {}",
      "\tvoid update(int pos, ll dif) { // a[pos] += dif",
      "\t\tfor (; pos < s.size(); pos |= pos + 1) s[pos] += dif;",
      "\t}",
      "\tll query(int pos) { // sum of values in [0, pos)",
      "\t\tll res = 0;",
      "\t\tfor (; pos > 0; pos &= pos - 1) res += s[pos-1];",
      "\t\treturn res;",
      "\t}",
      "\tint lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
      "\t\t// Returns n if no sum is >= sum, or -1 if empty sum is.",
      "\t\tif (sum <= 0) return -1;",
      "\t\tint pos = 0;",
      "\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {",
      "\t\t\tif (pos + pw <= s.size() && s[pos + pw-1] < sum)",
      "\t\t\t\tpos += pw, sum -= s[pos-1];",
      "\t\t}",
      "\t\treturn pos;",
      "\t}",
      "};"
    ],
    "description": "fenwick"
  },
  "factorial": {
    "prefix": "factorial",
    "body": [
      "vector<mint> fact(1, 1);",
      "vector<mint> inv_fact(1, 1);",
      "",
      "mint C(int n, int k) {",
      "  if (k < 0 || k > n) {",
      "    return 0;",
      "  }",
      "  while ((int) fact.size() < n + 1) {",
      "    fact.push_back(fact.back() * (int) fact.size());",
      "    inv_fact.push_back(1 / fact.back());",
      "  }",
      "  return fact[n] * inv_fact[k] * inv_fact[n - k];",
      "}"
    ],
    "description": "factorial"
  },
  "pragma": {
    "prefix": "pragma",
    "body": [
      "#pragma GCC optimize(\"O3\") // try Ofast",
      "#pragma GCC optimize(\"unroll-loops\")",
      "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
    ],
    "description": "pragma"
  }
}