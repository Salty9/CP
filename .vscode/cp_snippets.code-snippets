{
  "pragma": {
    "prefix": "pragma",
    "body": [
      "#pragma GCC optimize(\"O3\") // try Ofast",
      "#pragma GCC optimize(\"unroll-loops\")",
      "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
    ],
    "description": "pragma"
  },
  "base": {
    "prefix": "base",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#ifdef LOCAL_PROJECT",
      "#include \"debug.hpp\"",
      "#else",
      "#define dbg(...)",
      "#endif",
      "",
      "#define endl '\\n'",
      "#define pb push_back",
      "#define all(v) v.begin(), v.end()",
      "#define rep(i,a,b) for (int i = (a); i < (b); ++i)",
      "#define rrep(i,a,b) for (int i = (a); i >= (b); --i)",
      "",
      "typedef long long ll;",
      "typedef pair<int, int> pii;",
      "typedef vector<int> vi;",
      "template<class T> bool ckmin(T& a, T b){ return b < a ? a = b, 1 : 0; }",
      "template<class T> bool ckmax(T& a, T b){ return b > a ? a = b, 1 : 0; }",
      "template<class T> istream& operator>>(istream&i,vector<T>&v){for(T&x:v)i>>x;return i;}",
      "",
      "void solve(int tc = 0) {",
      "    $0",
      "}",
      "",
      "int main() {",
      "ios_base::sync_with_stdio(false);",
      "cin.tie(NULL); cout.tie(NULL);",
      "",
      "int tc = 1;",
      "$1cin >> tc;",
      "for(int t = 0; t < tc; t++) solve(t);",
      "}"
    ],
    "description": "base"
  },
  "mint": {
    "prefix": "mint",
    "body": [
      "template<int MOD, int RT> struct Mint {",
      "    static const int mod = MOD;",
      "    static constexpr Mint rt() { return RT; } // primitive root for FFT",
      "    int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
      "    Mint():v(0) {}",
      "    Mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD); if (v < 0) v += MOD; }",
      "",
      "    bool operator==(const Mint& o) const { return v == o.v; }",
      "    friend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }",
      "    friend bool operator<(const Mint& a, const Mint& b) { return a.v < b.v; }",
      "",
      "    Mint& operator+=(const Mint& o) { if ((v += o.v) >= MOD) v -= MOD; return *this; }",
      "    Mint& operator-=(const Mint& o) { if ((v -= o.v) < 0) v += MOD; return *this; }",
      "    Mint& operator*=(const Mint& o) { v = int((ll)v*o.v%MOD); return *this; }",
      "    Mint& operator/=(const Mint& o) { return (*this) *= inv(o); }",
      "    friend Mint pow(Mint a, ll p) {",
      "        Mint ans = 1; assert(p >= 0);",
      "        for (; p; p /= 2, a *= a) if (p&1) ans *= a; return ans; }",
      "    friend Mint inv(const Mint& a) { assert(a.v != 0); return pow(a,MOD-2); }",
      "",
      "    Mint operator-() const { return Mint(-v); }",
      "    Mint& operator++() { return *this += 1; }",
      "    Mint& operator--() { return *this -= 1; }",
      "    friend Mint operator+(Mint a, const Mint& b) { return a += b; }",
      "    friend Mint operator-(Mint a, const Mint& b) { return a -= b; }",
      "    friend Mint operator*(Mint a, const Mint& b) { return a *= b; }",
      "    friend Mint operator/(Mint a, const Mint& b) { return a /= b; }",
      "    friend ostream& operator<<(ostream &out, const Mint &m) {return out << m.v;}",
      "    friend istream& operator>>(istream &in, Mint &m) {long long x; in >> x; m = Mint(x); return in;}",
      "};",
      "const int MOD = (int)1e9 + 7; // change accordingly",
      "using mint = Mint<MOD,5>;"
    ],
    "description": "mint"
  },
  "lazy_segtree": {
    "prefix": "lazy_segtree",
    "body": [
      "template<class Lazy, class Data>",
      "struct LazySeg {",
      "    vector<Lazy> lazy;",
      "    vector<Data> seg;",
      "    int SZ = 1;",
      "    LazySeg(const int _sz) {",
      "        while (SZ < _sz) SZ *= 2;",
      "        seg.resize(2*SZ); lazy.resize(2*SZ);",
      "    }",
      "    LazySeg(const vector<Data>& _seg) {",
      "        while (SZ < _seg.size()) SZ *= 2;",
      "        seg.resize(2*SZ); lazy.resize(2*SZ);",
      "        for(int i = 0; i < SZ and i < _seg.size(); i++) seg[SZ+i] = _seg[i];",
      "        for(int i = SZ-1; i >= 1; i--) pull(i);",
      "    }",
      "    void push(int ind) {// modify values for current node (lazy upds floatin until pushed)",
      "        seg[ind] *= lazy[ind];",
      "        if (ind < SZ) rep(i,0, 2) lazy[2*ind+i] *= lazy[ind];",
      "        lazy[ind] = Lazy();",
      "    } // recalc values for current node",
      "    void pull(int ind) { seg[ind] = seg[2*ind]+seg[2*ind+1]; }",
      "",
      "    void upd(int lo, int hi, Lazy inc, int ind, int L, int R) {",
      "        push(ind); if (hi < L || R < lo) return;",
      "        if (lo <= L && R <= hi) { lazy[ind] = inc; push(ind); return;}",
      "        int M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M);",
      "        upd(lo,hi,inc,2*ind+1,M+1,R);",
      "        pull(ind);",
      "    }",
      "    void upd(int lo, int hi, Lazy inc) { return upd(lo, hi, inc, 1, 0, SZ-1); }",
      "",
      "    Data query(int lo, int hi, int ind, int L, int R) {",
      "        push(ind); if (lo > R || L > hi) return Data();",
      "        if (lo <= L && R <= hi) return seg[ind];",
      "        int M = (L+R)/2;",
      "        return query(lo,hi,2*ind,L,M) + query(lo,hi,2*ind+1,M+1,R);",
      "    }",
      "    Data query(int lo, int hi){ return query(lo, hi, 1, 0, SZ-1);}",
      "    // 0 based inclusive range for query and upd",
      "};",
      "struct Lazy {",
      "    int mx = -1e9;",
      "    Lazy() {}",
      "    Lazy(int x) { mx = x; }",
      "    Lazy& operator*=(const Lazy& a) {",
      "        ckmax(mx, a.mx);",
      "        return *this;",
      "    }",
      "};",
      "struct Data { // data you need to store for each interval",
      "    int mx = -1e9;",
      "    Data() {}",
      "    Data(int x) { mx = x; }",
      "    friend Data operator+(const Data& a, const Data& b) {",
      "        return Data(max(a.mx, b.mx));",
      "    }",
      "    Data& operator*=(const Lazy& a) {",
      "        // sum += sz*a.add;",
      "        ckmax(mx, a.mx);",
      "        return *this;",
      "    }",
      "};",
      "// Data A + Data B, + operation just has be associative, Data() should return identity element Data A + Data() = Data A",
      "// if F is update applied on intervals,",
      "// 1) need identiy update",
      "// 2) need F(Data A + Data B) = F(Data A) + F(Data B)"
    ],
    "description": "lazy_segtree"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "template<class T> struct Segtree {",
      "   // initialize ID if need nonzero & define cmb so that cmb(ID,b) = b",
      "    const T ID = 0;",
      "    T cmb(T a, T b) {",
      "        return a + b;",
      "    }",
      "    int n = 1; vector<T> seg;",
      "    Segtree(int _n){while(n < _n) n *= 2; seg.assign(2*n,ID);}",
      "",
      "    void pull(int p) { seg[p] = cmb(seg[2*p],seg[2*p+1]); }",
      "    void upd(int p, T val) { seg[p += n] = val; for (p /= 2; p; p /= 2) pull(p); }",
      "    T query(int l, int r) {",
      "        T ra = ID, rb = ID;",
      "        for (l += n, r += n+1; l < r; l /= 2, r /= 2) {",
      "            if (l&1) ra = cmb(ra,seg[l++]);",
      "            if (r&1) rb = cmb(seg[--r],rb);",
      "        }",
      "        return cmb(ra,rb);",
      "    }",
      "    // 0 based range and index for upd and query, root at 1, 2*ind, 2*ind + 1 children",
      "    template<class F>",
      "    int find_first(int p, int l, int r, int x, int y, F &&pred) {",
      "        if (l > y || r < x) return -1;",
      "        if (l >= x && r <= y && !pred(seg[p])) return -1;",
      "        if (r == l) return l;",
      "        int m = (l + r) / 2;",
      "        int res = find_first(2 * p, l, m, x, y, pred);//find_last: flip res order(right range 1st)",
      "        if (res == -1) res = find_first(2 * p + 1, m+1, r, x, y, pred);",
      "        return res;",
      "    }",
      "    template<class F> // given 0 based inclusive range [x, y], first time pred(use lambda) is true",
      "    int find_first(int l, int r, F &&pred) { return find_first(1, 0, n-1, l, r, pred); }",
      "};"
    ],
    "description": "segtree"
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct Dsu {",
      "\tvector<int> p;",
      "\tDsu(int n) : p(n, -1) {}",
      "\tbool sameSet(int a, int b) { return parent(a) == parent(b); }",
      "\tint size(int x) { return -p[parent(x)]; }",
      "\tint parent(int x) { return p[x] < 0 ? x : p[x] = parent(p[x]); }",
      "\tbool unite(int a, int b) {",
      "\t\ta = parent(a), b = parent(b);",
      "\t\tif (a == b) return false;",
      "\t\tif (p[a] > p[b]) swap(a, b);",
      "\t\tp[a] += p[b]; p[b] = a;",
      "\t\treturn true;",
      "\t}",
      "};"
    ],
    "description": "dsu"
  },
  "pbds": {
    "prefix": "pbds",
    "body": [
      "#include <bits/extc++.h>",
      "using namespace __gnu_pbds;",
      "",
      "template<class T>",
      "using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "// Usage: Tree<int> t; order_of_key, find_by_order",
      "// submit with g++177"
    ],
    "description": "pbds"
  },
  "random": {
    "prefix": "random",
    "body": [
      "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());"
    ],
    "description": "random"
  },
  "factorial": {
    "prefix": "factorial",
    "body": [
      "vector<mint> fact(1, 1);",
      "vector<mint> inv_fact(1, 1);",
      "",
      "mint C(int n, int k) {",
      "  if (k < 0 || k > n) {",
      "    return 0;",
      "  }",
      "  while ((int) fact.size() < n + 1) {",
      "    fact.push_back(fact.back() * (int) fact.size());",
      "    inv_fact.push_back(1 / fact.back());",
      "  }",
      "  return fact[n] * inv_fact[k] * inv_fact[n - k];",
      "}"
    ],
    "description": "factorial"
  },
  "timeit": {
    "prefix": "timeit",
    "body": [
      "#ifdef LOCAL_PROJECT",
      "    auto begin = std::chrono::high_resolution_clock::now();",
      "    // freopen(\"input\",\"r\",stdin);",
      "    //freopen(\"a.out\",\"w\",stdout); // console output is better (in most cases)",
      "#endif",
      "",
      "#ifdef LOCAL_PROJECT",
      "    auto end = std::chrono::high_resolution_clock::now();",
      "    cerr << setprecision(4) << fixed;",
      "    cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;",
      "#endif"
    ],
    "description": "timeit"
  },
  "gp_hash_table": {
    "prefix": "gp_hash_table",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "struct custom_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "};",
      "",
      "template<typename S, typename T>",
      "using hash_table = gp_hash_table<S, T, custom_hash>;",
      "// Usage: hashtable<int, int> for map<int, int> basically",
      "// replacement for unordered_set<K>, use gp_hash_table<K, null_type>",
      "// Note: the operator needs to be able to hash the typename S",
      "",
      "",
      "// untested but could be used for pairs",
      "// the hashes need to be non symmetric ((a, b) and (b, a) should give diff hash)",
      "// eg: splitmix64(x.first ^ splitmix64(x.second) ^ FIXED_RANDOM) works",
      "// but splitmix64(x.first ^ x.second ^ FIXED_RANDOM) doesnt since (1, 2) and (2, 1) give same hash",
      "",
      "// maybe this for pairs",
      "",
      "// size_t operator()(pair<uint64_t, uint64_t> x) const {",
      "// static const uint64_t FIXED_RANDOM =",
      "//     chrono::steady_clock::now().time_since_epoch().count();",
      "//     return splitmix64(x.first ^ splitmix64(x.second) ^ FIXED_RANDOM);",
      "// }",
      "",
      "//maybe this for strings",
      "",
      "// size_t operator()(string x) const {",
      "//   static const uint64_t FIXED_RANDOM =",
      "//       chrono::steady_clock::now().time_since_epoch().count();",
      "//   uint64_t hash = 0;",
      "//   for (char c : x){",
      "//       hash = splitmix64(hash ^ (c + 1) ^ FIXED_RANDOM);",
      "//   }",
      "//   return hash;",
      "// }"
    ],
    "description": "gp_hash_table"
  }
}