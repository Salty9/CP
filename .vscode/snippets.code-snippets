{
	"base_template": {
  "prefix": "base",
  "body": [
    "#include <bits/stdc++.h>",
    "#include <chrono>",
    "using namespace std;",
    "using namespace std::chrono;",
    "",
    "#ifdef LOCAL_PROJECT",
    "    #include \"debug.hpp\"",
    "#else",
    "    #define dbg(...)",
    "#endif",
    "",
    "#define endl '\\n'",
    "#define pb push_back",
    "#define all(v) v.begin(), v.end()",
    "#define rep(i,a,b) for (int i = a; i < b; i++)",
    "#define revrep(i,a,b) for (int i = a; i >= b; i--)",
    "#define vin(a) for(auto& x: a) cin >> x;",
    "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)",
    "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "typedef long long ll;",
    "typedef pair<int, int> pii;",
    "typedef pair<ll, ll> pll;",
    "typedef vector<int> vi;",
    "typedef vector<ll> vll;",
    "template<class T> bool ckmin(T& a, T b){ return b < a ? a = b, 1 : 0; }",
    "template<class T> bool ckmax(T& a, T b){ return b > a ? a = b, 1 : 0; }",
    "",
    "",
    "void solve(int tc = 0) {",
    "    ",
    "}",
    "",
    "int main() {",
    "",
    "#ifdef LOCAL_PROJECT",
    "    auto begin = std::chrono::high_resolution_clock::now();",
    "    freopen(\"input\",\"r\",stdin);",
    "    //freopen(\"a.out\",\"w\",stdout); // console output is better (in most cases)",
    "#endif",
    "",
    "ios_base::sync_with_stdio(false);",
    "cin.tie(NULL); cout.tie(NULL);",
    "",
    "int tc = 1;",
    "cin >> tc;",
    "",
    "for (int t = 0; t < tc; t++) solve(t);",
    "",
    "#ifdef LOCAL_PROJECT",
    "    auto end = std::chrono::high_resolution_clock::now();",
    "    cerr << setprecision(4) << fixed;",
    "    cerr << \"Execution time: \" << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << \" seconds\" << endl;",
    "#endif",
    "}"
  ],
  "description": "base_template"
	},

  "modular int": {
  "prefix": "mint",
  "body": [
    "template<int MOD, int RT> struct Mint {",
    "static const int mod = MOD;",
    "static constexpr Mint rt() { return RT; } // primitive root for FFT",
    "    int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
    "    Mint():v(0) {}",
    "    Mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
    "       if (v < 0) v += MOD; }",
    "    bool operator==(const Mint& o) const {",
    "       return v == o.v; }",
    "    friend bool operator!=(const Mint& a, const Mint& b) { ",
    "       return !(a == b); }",
    "    friend bool operator<(const Mint& a, const Mint& b) { ",
    "       return a.v < b.v; }",
    "    // friend void re(Mint& a) { ll x; re(x); a = Mint(x); }",
    "    // friend str ts(Mint a) { return ts(a.v); }",
    "   ",
    "    Mint& operator+=(const Mint& o) { if ((v += o.v) >= MOD) v -= MOD; return *this; }",
    "    Mint& operator-=(const mint& o) { if ((v -= o.v) < 0) v += MOD; return *this; }",
    "    Mint& operator*=(const Mint& o) { v = int((ll)v*o.v%MOD); return *this; }",
    "    Mint& operator/=(const Mint& o) { return (*this) *= inv(o); }",
    "    friend Mint pow(Mint a, ll p) {",
    "        Mint ans = 1; assert(p >= 0);",
    "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
    "        return ans; }",
    "    friend Mint inv(const Mint& a) { assert(a.v != 0); ",
    "        return pow(a,MOD-2); }",
    "   ",
    "    Mint operator-() const { return mint(-v); }",
    "    Mint& operator++() { return *this += 1; }",
    "    Mint& operator--() { return *this -= 1; }",
    "    friend Mint operator+(Mint a, const Mint& b) { return a += b; }",
    "    friend Mint operator-(Mint a, const Mint& b) { return a -= b; }",
    "    friend Mint operator*(Mint a, const Mint& b) { return a *= b; }",
    "    friend Mint operator/(Mint a, const Mint& b) { return a /= b; }",
    "};",
    "const int MOD = (int)1e9 + 7; // change accoridngly",
    "using mint = Mint<MOD,5>;"
  ],
  "description": "modular int"
    }
}